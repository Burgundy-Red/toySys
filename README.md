### Bootloader

    1. 通过读取硬盘指定位置实现
    
    2. 硬盘控制端口
    | Primary 通道            | Secondary 通道 | in 操作      | out 操作     |
    | ----------------------- | -------------- | ------------ | ------------ |
    | 0x1F0                   | 0x170          | Data         | Data         |
    | 0x1F1                   | 0x171          | Error        | Features     |
    | 0x1F2                   | 0x172          | Sector count | Sector count |
    | 0x1F3                   | 0x173          | LBA low      | LBA low      |
    | 0x1F4                   | 0x174          | LBA mid      | LBA mid      |
    | 0x1F5                   | 0x175          | LBA high     | LBA high     |
    | 0x1F6                   | 0x176          | Device       | Device       |
    | 0x1F7                   | 0x177          | Status       | Command      |

### 内存检测

    BIOS 0x15 0xe820
    
### 实模式到保护模式

    1. 实模式缺点： 
        - 实模式下操作系统和用户程序属于同一特权级
        - 用户程序所引用的地址都是指向真实的物理地址
        - 用户程序可以自由修改段基址，不受阻碍地访问所有内存
        - 访问超过 64KB 的内存区域时要切换段基址
    2. 保护模式如何解决：
        - 地址转换：在开启分页机制后，程序引用的地址、CPU执行机器指令时处理的地址都变成了虚拟地址，
          需要转化为物理地址后再去访问，地址转换由 处理器 和 操作系统 共同完成。处理器提供硬件，操
          作系统提供页表。
        - 兼容实模式：实模式是 32位CPU 运行在 16位模式 下的状态，此时 CPU 相当于更加强大的16位CPU，
          可以处理32位的操作数。
        - 段保护：在实模式下，程序访问内存段时，CPU 会完成对用户的权限检查，防止出现错误
    3. 需要哪些步骤：
        - 打开A20地址线：通过0x92端口
        - 加载GDT：OS 会在 loader 代码中定义GDT，然后更新 gdtr 指向这一段内存，CPU 通过段寄存器存储段选择子，
          访问地址首先通过段描述符表获得段描述符，然后通过段描述符得到段基址去访问，在这一过程，加载段选择子
          和获得访问地址的过程中都会进行内存保护，如果保护失败就抛出异常。
        - 将 cr0 的pe置为0
    
### elf文件格式

    ![参考](https://www.zhihu.com/column/c_1593393144703369216) 
    **其中虚拟地址和物理地址是如何映射的？**
    
### 内核全局描述符

    将loader中保存的全局描述符表和指针保存在内核中
    - lgdt [gdt_ptr]; 加载 gdt
    - sgdt [gdt_ptr]; 保存 gdt
    
### 任务切换

    ABI 调用约定 Application Binary Interface (System V ABI)

    1. 调用方保存：
        eax ecx edx
    2. 实现方保存，调用完成后寄存器值不变：
        ebx esi edi ebp esp
        
    schedule.asm 中实现，任务主动放弃执行，相当于协程。
    
### 中断(实模式)
    
    中断向量表（0x000 ~ 0x3ff）中保存256个中断函数指针(4字节, 段地址<<4+偏移地址, 低位偏移地址,高位段地址)
    
    1. 注册中断向量表
    2. 调用方式:
        - int / iret： 保存 eip, cs, eflags 值
        - int nr ; 中断函数编号
    3. 异常中断一般在异常处理函数中结束程序

### 中断进阶

    
    - 引发中断的方式有三种: 外中断 异常 软中断
    
        1. 外中断就是由外部中断控制器通知 CPU 需要执行的，CPU 在当前指令执行完成之后，回去检测是否有中断产生，
           如果有，并且 IF 位有效，也就是允许中断，那么就会执行中断处理函数，这种方式直接的体验就是，CPU 可以
           在任意两个指令间插入一个中断函数调用，中断函数调用与普通函数调用稍有区别，在调用时栈中多压了一些数
           据，在中断返回时，会弹出；
        
        - 异常和软中断统称为 内中断，也就是这个中断时 CPU 和 软件内部产生的，与外部硬件无关；

        2. 异常是 CPU 在执行过程中，执行不下去了，引发的中断调用，比如 除零异常，缺页异常，一般保护错误，有一
           些异常在处理后程序是可以继续执行的，比如缺页异常，而有一些异常就不行了，比如一般保护，这种情况下一
           般是软件访问了不该访问的内存或者寄存器，自己没有权限，于是CPU会调用一般保护异常函数，这个函数中，一
           般会终止该进程的执行，试图访问自己没有权限的内容，应该是危险的程序，可能是恶意程序，或者是程序有漏洞；

        3. 软中断，可以认为是应用程序和操作系统沟通的一种方式，应用程序运行在较低的特权级，一般来说没有直接访
           问硬件的权限，当应用程序想要访问硬件的时候，比如典型的读写文件，就需要调用系统调用，系统调用就是用
           软中断实现的，也就是应用程序调用软中断函数来请求操作系统，以访问硬件，访问硬件的函数是操作系统实现
           的，于是被认为是安全的。
        
    - 内核用中 **中断描述符表和中断描述符** 管理中断

    ```c++
    // 中断描述符
    typedef struct gate_t {
        u16 offset0;    // 段内偏移 0 ~ 15 位
        u16 selector;   // 代码段选择子
        u8 reserved;    // 保留不用
        u8 type : 4;    // 任务门/中断门/陷阱门
        u8 segment : 1; // segment = 0 表示系统段
        u8 DPL : 2;     // 使用 int 指令访问的最低权限
        u8 present : 1; // 是否有效
        u16 offset1;    // 段内偏移 16 ~ 31 位
    } _packed gate_t;
    
    // 中段描述符表
    gate_t idt[256];
    ```

### 内存管理

    1. 初步
        - 得到loader中内存检查结果（将储存结果的地址压栈，当做函数参数）
        - 找到可用内存（type=1，基址1M 0x100000）
    2. 物理内存管理
        - 可用内存开始位置一些页用于管理物理内存
        - 每一个物理页用一个字节表示引用数量
        - get_page(), put_page();
    3. ** 分页机制 **(平坦模型)
        - 虚拟地址 -> 页目录(cr3寄存器) -> 页表 -> 页 + 偏移
          4M = 4K * 1024，也就是需要1024个页存储;
          用页目录表示这1024个页，用到了哪些页，一页页表4B，总共4KB。
        - 使用
          (1) 按照地址结构将逻辑地址拆成三个部分。
          (2) 从PCB中读取页目录起始地址，再根据一级页号查页目录表，找到下一级页表在内存中存放位置。
          (3) 根据二级页号查表，找到最终想要访问的内存块号。
          (4) 结合页内偏移量得到物理地址。
        
    4. 启用分页
        - 首先准备一个页目录，若干页表
        - 将映射的地址写入页表，将页表写入页目录
        - 将页目录写入 cr3 寄存器
        - 将 cr0 最高位 (PG) 置为 1，启用分页机制
        
### DEBUG

    vsprintf
    sprintf
    printk
    显示驱动
