### Bootloader

    1. MBR 只有512B，放不下所有代码
    
    2. boot -> loader -> kernel
    
    硬盘读取：
        - 硬盘控制端口
        | Primary 通道            | Secondary 通道 | in 操作      | out 操作     |
        | ----------------------- | -------------- | ------------ | ------------ |
        | 0x1F0                   | 0x170          | Data         | Data         |
        | 0x1F1                   | 0x171          | Error        | Features     |
        | 0x1F2                   | 0x172          | Sector count | Sector count |
        | 0x1F3                   | 0x173          | LBA low      | LBA low      |
        | 0x1F4                   | 0x174          | LBA mid      | LBA mid      |
        | 0x1F5                   | 0x175          | LBA high     | LBA high     |
        | 0x1F6                   | 0x176          | Device       | Device       |
        | 0x1F7                   | 0x177          | Status       | Command      |

### 内存检测

    BIOS 0x15 0xe820
    
    注意：将ards_buffer放到最后，因为不知道会有多长
    
### 实模式到保护模式

    1. 实模式缺点： 
        - 实模式下操作系统和用户程序属于同一特权级
        - 用户程序所引用的地址都是指向真实的物理地址
        - 用户程序可以自由修改段基址，不受阻碍地访问所有内存
        - 访问超过 64KB 的内存区域时要切换段基址
    2. 保护模式如何解决：
        - 地址转换：在开启分页机制后，程序引用的地址、CPU执行机器指令时处理的地址都变成了虚拟地址，
          需要转化为物理地址后再去访问，地址转换由 处理器 和 操作系统 共同完成。处理器提供硬件，操
          作系统提供页表。
        - 兼容实模式：实模式是 32位CPU 运行在 16位模式 下的状态，此时 CPU 相当于更加强大的16位CPU，
          可以处理32位的操作数。
        - 段保护：在实模式下，程序访问内存段时，CPU 会完成对用户的权限检查，防止出现错误
    3. 需要哪些步骤：
        - 打开A20地址线：通过0x92端口
        - 加载GDT：OS 会在 loader 代码中定义GDT，然后更新 gdtr 指向这一段内存，CPU 通过段寄存器存储段选择子，
          访问地址首先通过段描述符表获得段描述符，然后通过段描述符得到段基址去访问，在这一过程，加载段选择子
          和获得访问地址的过程中都会进行内存保护，如果保护失败就抛出异常。
        - 将 cr0 的pe置为0
    
    注意：一个nasm文件里,同时会处理16或者32位,例如在写实模式跳转到保护模式,在初始化保护模式中最后一句跳转指令所跳到
        的标号地址一定再[bits 32]下面。(16位代码段和32位代码段的主要区别是，在16位代码段中，跳转目标的偏移用16位表示，
        而在32位代码段中，跳转目标的偏移用32位表示。)
    
### 内核全局描述符

    将loader中保存的全局描述符表和指针保存在内核中
    - lgdt [gdt_ptr]; 加载 gdt
    - sgdt [gdt_ptr]; 保存 gdt

    注意：selector
    ```c++
        typedef struct selector_t
        {
            u8 RPL : 2;
            u8 TI : 1;
            u16 index : 13;
        } selector_t;
        // 代码段 1 << 3 
    ```
    
### 中断
    
    - 实模式下：
        中断向量表（0x000 ~ 0x3ff）中保存256个中断函数指针(4字节, 段地址<<4+偏移地址, 低位偏移地址,高位段地址)
        
        1. 注册中断向量表
        2. 调用方式:
            - int / iret： 保存 [错误码], eip, cs, eflags 值
            - int nr ; 中断函数编号
        3. 异常中断一般在异常处理函数中结束程序

    - 保护模式下：
        中断描述符表可放在内核任意位置
        需要先注册中断处理函数
        
    - 引发中断的方式有三种: 外中断 异常 软中断
    
        1. 外中断就是由外部中断控制器通知 CPU 需要执行的，CPU 在当前指令执行完成之后，回去检测是否有中断产生，
           如果有，并且 IF 位有效，也就是允许中断，那么就会执行中断处理函数，这种方式直接的体验就是，CPU 可以
           在任意两个指令间插入一个中断函数调用，中断函数调用与普通函数调用稍有区别，在调用时栈中多压了一些数
           据，在中断返回时，会弹出；
        
        - 异常和软中断统称为 内中断，也就是这个中断时 CPU 和 软件内部产生的，与外部硬件无关；

        2. 异常是 CPU 在执行过程中，执行不下去了，引发的中断调用，比如 除零异常，缺页异常，一般保护错误，有一
           些异常在处理后程序是可以继续执行的，比如缺页异常，而有一些异常就不行了，比如一般保护，这种情况下一
           般是软件访问了不该访问的内存或者寄存器，自己没有权限，于是CPU会调用一般保护异常函数，这个函数中，一
           般会终止该进程的执行，试图访问自己没有权限的内容，应该是危险的程序，可能是恶意程序，或者是程序有漏洞；

        3. 软中断，可以认为是应用程序和操作系统沟通的一种方式，应用程序运行在较低的特权级，一般来说没有直接访
           问硬件的权限，当应用程序想要访问硬件的时候，比如典型的读写文件，就需要调用系统调用，系统调用就是用
           软中断实现的，也就是应用程序调用软中断函数来请求操作系统，以访问硬件，访问硬件的函数是操作系统实现
           的，于是被认为是安全的。

    注意：有的中断会压入错误码，可以压入一个随机数，保持后续操作一致
    错误码
    
    - 外中断原理
        指令执行流程：
            取指：将 eip 指向的指令读入处理器
            译码：将指令的微程序写入流水线 (多级 cache)
            执行：执行指令
            中断：处理中断
        
        IF: Interrupt Flag 外中断允许标志，CPU 外中断的总开关
        
        sti; 设置 IF 位 (set interrupt)，允许外中断
        cli; 清除 IF 位 (clear interrupt)，禁止外中断

        pushf; 将 elags 压入栈中
        popf; 将栈顶弹出到 eflags
        
        检测IF位(是否开启中断)，检测INTR引脚(级联8259a芯片)，得到中断编号，执行

        利用外中断(时钟中断)进行任务切换：
        ![](/images/interrupt_context.drawio.svg)  
        ![](https://github.com/Burgundy-Red/toySys/blob/main/images/interrupt_context.drawio.svg)  
    
    TODO: 初始化外中断步骤
    
### 内存管理

    1. 初步
        - 得到loader中内存检查结果（将储存结果的地址压栈，当做函数参数）
        - 找到可用内存（type=1，基址1M 0x100000）
        
    2. 物理内存管理
        - 可用内存开始位置一些页用于管理物理内存
        - 每一个物理页用一个字节表示引用数量
        - get_page(), put_page();
        
    3. ** 分页机制 **(平坦模型)
        - 虚拟地址 -> 页目录(cr3寄存器) -> 页表 -> 页 + 偏移
          4M = 4K * 1024，也就是需要1024个页存储;
          用页目录表示这1024个页，用到了哪些页，一页页表4B，总共4KB。
        - 使用
          (1) 按照地址结构将逻辑地址拆成三个部分(10,10,12)。
          (2) 从PCB中读取页目录起始地址，再根据一级页号查页目录表，找到下一级页表在内存中存放位置。
          (3) 根据二级页号查表，找到最终想要访问的内存块号。
          (4) 结合页内偏移量得到物理地址。
        
    4. 启用分页
        - 首先准备一个页目录，若干页表
        - 将映射的地址写入页表，将页表写入页目录
        - 将页目录写入 cr3 寄存器
        - 将 cr0 最高位 (PG) 置为 1，启用分页机制
        
### DEBUG

    vsprintf
    sprintf
    printk
    显示驱动
